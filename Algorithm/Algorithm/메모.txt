
// 선형 자료구조

배열 vs 동적 배열(vector) vs 연결 리스트(list)

배열 :		- 사용할 방 개수를 고정해서 계약 (절대 변경 불가)
			- 연속된 방으로 배정 받아 사용
			장점 : 연속된 방
			단점 : 방을 추가 / 축소 불가

동적배열 :	- 사용할 방 개수를 유동적으로 계약
			- 연속된 방으로 배정 받아서 사용
			이사 비용 (할당받은 방 이상으로 추가하려면 단체로 이동해야 하기 때문에 비용 발생)
			그래서 메모리 할당 정책 : 실제로 사용할 방보다 많이 여유분을 가지고 예약(약 1.5배) <- 이사 횟수를 최소화
			장점 : 유동적인 계약(방 여유분 추가 예약)
			단점 : 중간 삽입 삭제(배열 자체의 문제 중간에 삽입하면 뒤로 밀어야함)

연결리스트 : - 연속되지 않는 방을 사용
			장점 : 중간 삽입 / 삭제 이점
			단점 : n번째 방을 바로 찾을 수가 없음 == 임의 접근이 불가능(인덱스)



// 비선형 자료구조

그래프 :		- 연결관계 표현 정점(Vertex)과 간선(Edge)
			- 도로교통망, 소셜 네트워크 관계도 (1 : 1이 아니라 다수와 연결)
			- 가중치 그래프 : 연결관계 + 간선의 가중치 ( ex) 지하철 노선도에서의 간선에 거리별로 가중치를 둠 )
			- 방향 그래프 : 간선에 방향이 있는 그래프


DFS(깊이 우선 탐색) * 탐색 : 모든 데이터 순차로 도는 것
			- 길이 있으면 끝까지 들어감 

BFS(너비 우선 탐색) 
			- 입구를 기준으로 가까운 것부터 돌려고 함 
			- 큐로 예약시스템(방문 해야할 곳을 큐에 넣어둠)


트리 : 계층적 구조를 갖는 데이터를 표현하기 위한 자료구조

힙트리  

	ㄴ특징 :	- [부모 노드]가 가진 값은 항상 [자식 노드]가 가진 값보다 크다
			- 마지막 레벨을 제외한 모든 레벨에 노드가 꽉 차 있다(완전 이진트리)
			- 마지막 레벨에 노드가 있을 때는, 항상 왼쪽부터 순서대로 채워야 한다. 
			- i 번 노드의 왼쪽 자식 노드 번호는 ((2 * i) + 1)
			- i 번 노드의 오른쪽 자식 노드 번호는 ((2 * i) + 2)
			- i 번 노드의 부모 노드 번호는 ((i - 1) / 2)

			- 삽입 : 새로운 데이터 추가할 때 일단 순서상 노드 끝에 추가하고. 부모가 자식보다 큰 조건을 맞춰가면 된다.
			- 힙트리는 최대값을 꺼내는데 유리한 자료구조

이진 탐색 트리 : 각 노드의 왼쪽 서브트리에는 해당 노드의 값보다 작은 값을 지닌 노드들로 이루어져 있다.
				각 노드의 오른쪽 서브트리에는 해당 노드의 값보다 큰 값을 지닌 노드들로 이루어져 있다.


레드 블랙 트리 : 노드는 레드 혹은 블랙 중의 하나이다.
				루트 노드는 블랙이다.
				모든 리프 노드(NIL)들은 블랙이다 (없는 데이터도 더미노드로 만들어서 검은색으로 인지 해야함)
				레드 노드의 자식노드 양쪽은 언제나 모두 블랙이다. 블랙->레드->블랙 ㅇ 블랙->블랙->블랙은 가능
				레드 트리로 노드 추가

				삭제 : 삭제할때 삭제할 노드가 레드노드면 상관없지만 블랙노드면 문제가 발생
